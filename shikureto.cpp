// shikureto_dump.cpp : définit le point d'entrée pour l'application console.
//

#include "stdafx.h"

#include <windows.h>
#include <wincrypt.h>

int string_length(char* p){ // longueur d'un char*
	int i = 0;
	while(p[i]!='\0'){
		i++;
	}
	return i;
}

// temporaire, a integrer dans main
// retourne le couple (numero de l'argument argv, indice du cararactere dans cet argument) de l'input a print

void print_pointer(int i, int argc, _TCHAR* argv[], int tableau[]){
	int j = 1;
	int longueur;
	if (i < string_length((char *) argv[1]) + 1){
		tableau[0] = 1;
		tableau[1] = i - 1;
		tableau[2] = 0;
	}
	else if (i == string_length((char *) argv[1]) + 1){
		tableau[0] = 1;
		tableau[1] = i - 1;
		tableau[2] = 1;
	}
	else{
		longueur = string_length((char *) argv[1]) + 1;
		while ((j < argc - 2) && (i > longueur + string_length((char *) argv[j+1]) + 1)){
			j++;
			longueur += string_length((char *) argv[j]) + 1;
		}
		if (i < longueur + string_length((char *) argv[j+1]) + 1){
			tableau[0] = j+1;
			tableau[0] = j+1;
			tableau[1] = i - longueur - 1;
			tableau[2] = 0;
		}
		else{
			tableau[0] = j+1;
			tableau[1] = i - longueur - 1;
			tableau[2] = 1;
		}
	}
}


PBYTE sha256(char* d1, char* d2){

	//--------------------------------------------------------------------
	// Declare variables.
	//
	// hProv:           Handle to a cryptographic service provider (CSP). 
	//                  This example retrieves the default provider for  
	//                  the PROV_RSA_FULL provider type.  
	// hHash:           Handle to the hash object needed to create a hash.
	// hKey:            Handle to a symmetric key. This example creates a 
	//                  key for the RC4 algorithm.
	// hHmacHash:       Handle to an HMAC hash.
	// pbHash:          Pointer to the hash.
	// dwDataLen:       Length, in bytes, of the hash.
	// Data1:           Password string used to create a symmetric key.
	// Data2:           Message string to be hashed.
	// HmacInfo:        Instance of an HMAC_INFO structure that contains 
	//                  information about the HMAC hash.
	// 
	HCRYPTPROV  hProv       = NULL;
	HCRYPTHASH  hHash       = NULL;
	HCRYPTKEY   hKey        = NULL;
	HCRYPTHASH  hHmacHash   = NULL;
	PBYTE       pbHash      = NULL;
	DWORD       dwDataLen   = 0;
	BYTE *Data1= (BYTE*) malloc(sizeof(char)*((int)(strlen(d1)+1)))  ;
	for(int q=0; q< (int)(strlen(d1)+1);q++){
		Data1[q] = (BYTE) d1[q];
	}
	BYTE *Data2 = (BYTE*) malloc(sizeof(char)*(((int)strlen(d2)+1))) ;
	for(int q=0; q< (int)(strlen(d2)+1);q++){
		Data2[q] = (BYTE) d2[q];
	}


	//for(int q=0; q< (int)(strlen(d1));q++){
	//	printf("%c\n", (char) d1[q]);
	//}
	//
	//
	//for(int q=0; q< (int)(strlen(d2));q++){
	//	printf("%c\n", (char) d2[q]);
	//}

	DWORD ldata1 = (strlen(d1) + 1);
	DWORD ldata2 = (strlen(d2) + 1);

	//printf("Longueur = %d\n", strlen(d1));
	//printf("Longueur = %d\n", strlen(d2));


	HMAC_INFO   HmacInfo;

	//--------------------------------------------------------------------
	// Zero the HMAC_INFO structure and use the SHA1 algorithm for
	// hashing.

	ZeroMemory(&HmacInfo, sizeof(HmacInfo));
	HmacInfo.HashAlgid = CALG_SHA_256;

	//--------------------------------------------------------------------
	// Acquire a handle to the default RSA cryptographic service provider.

	if (!CryptAcquireContext(
		&hProv,                   // handle of the CSP
		NULL,                     // key container name
		NULL,                     // CSP name
		PROV_RSA_AES,            // provider type
		CRYPT_VERIFYCONTEXT))     // no key access is requested
	{
	   printf(" Error in AcquireContext 0x%08x \n",
			  GetLastError());
	   goto ErrorExit;
	}

	//--------------------------------------------------------------------
	// Derive a symmetric key from a hash object by performing the
	// following steps:
	//    1. Call CryptCreateHash to retrieve a handle to a hash object.
	//    2. Call CryptHashData to add a text string (password) to the 
	//       hash object.
	//    3. Call CryptDeriveKey to create the symmetric key from the
	//       hashed password derived in step 2.
	// You will use the key later to create an HMAC hash object. 

	if (!CryptCreateHash(
		hProv,                    // handle of the CSP
		CALG_SHA_256,              // hash algorithm to use
		0,                        // hash key
		0,                        // reserved
		&hHash))                  // address of hash object handle
	{
	   printf("Error in CryptCreateHash 0x%08x \n",
			  GetLastError());
	   goto ErrorExit;
	}


	if (!CryptHashData(
		hHash,                    // handle of the hash object
		Data1,                    // password to hash
		ldata1,            // number of bytes of data to add
		0))                       // flags
	{
	   printf("Error in CryptHashData 0x%08x \n", 
			  GetLastError());
	   goto ErrorExit;
	}

	if (!CryptDeriveKey(
		hProv,                    // handle of the CSP
		CALG_RC4,                 // algorithm ID
		hHash,                    // handle to the hash object
		0,                        // flags
		&hKey))                   // address of the key handle
	{
	   printf("Error in CryptDeriveKey 0x%08x \n", 
			  GetLastError());
	   goto ErrorExit;
	}

	//--------------------------------------------------------------------
	// Create an HMAC by performing the following steps:
	//    1. Call CryptCreateHash to create a hash object and retrieve 
	//       a handle to it.
	//    2. Call CryptSetHashParam to set the instance of the HMAC_INFO 
	//       structure into the hash object.
	//    3. Call CryptHashData to compute a hash of the message.
	//    4. Call CryptGetHashParam to retrieve the size, in bytes, of
	//       the hash.
	//    5. Call malloc to allocate memory for the hash.
	//    6. Call CryptGetHashParam again to retrieve the HMAC hash.

	if (!CryptCreateHash(
		hProv,                    // handle of the CSP.
		CALG_HMAC,                // HMAC hash algorithm ID
		hKey,                     // key for the hash (see above)
		0,                        // reserved
		&hHmacHash))              // address of the hash handle
	{
	   printf("Error in CryptCreateHash 0x%08x \n", 
			  GetLastError());
	   goto ErrorExit;
	}

	if (!CryptSetHashParam(
		hHmacHash,                // handle of the HMAC hash object
		HP_HMAC_INFO,             // setting an HMAC_INFO object
		(BYTE*)&HmacInfo,         // the HMAC_INFO object
		0))                       // reserved
	{
	   printf("Error in CryptSetHashParam 0x%08x \n", 
			  GetLastError());
	   goto ErrorExit;
	}

	if (!CryptHashData(
		hHmacHash,                // handle of the HMAC hash object
		Data2,                    // message to hash
		ldata2,            // number of bytes of data to add
		0))                       // flags
	{
	   printf("Error in CryptHashData 0x%08x \n", 
			  GetLastError());
	   goto ErrorExit;
	}

	//--------------------------------------------------------------------
	// Call CryptGetHashParam twice. Call it the first time to retrieve
	// the size, in bytes, of the hash. Allocate memory. Then call 
	// CryptGetHashParam again to retrieve the hash value.

	if (!CryptGetHashParam(
		hHmacHash,                // handle of the HMAC hash object
		HP_HASHVAL,               // query on the hash value
		NULL,                     // filled on second call
		&dwDataLen,               // length, in bytes, of the hash
		0))
	{
	   printf("Error in CryptGetHashParam 0x%08x \n", 
			  GetLastError());
	   goto ErrorExit;
	}

	pbHash = (BYTE*)malloc(dwDataLen);
	if(NULL == pbHash) 
	{
	   printf("unable to allocate memory\n");
	   goto ErrorExit;
	}
    
	if (!CryptGetHashParam(
		hHmacHash,                 // handle of the HMAC hash object
		HP_HASHVAL,                // query on the hash value
		pbHash,                    // pointer to the HMAC hash value
		&dwDataLen,                // length, in bytes, of the hash
		0))
	{
	   printf("Error in CryptGetHashParam 0x%08x \n", GetLastError());
	   goto ErrorExit;
	}

	// Free resources.
	ErrorExit:
		if(hHmacHash)
			CryptDestroyHash(hHmacHash);
		if(hKey)
			CryptDestroyKey(hKey);
		if(hHash)
			CryptDestroyHash(hHash);    
		if(hProv)
			CryptReleaseContext(hProv, 0);
		return pbHash;
}

int main(int argc, _TCHAR* argv[])
{	
	// Pointeur instruction (forme argv)
	int tab[3];

	// Pointeur instruction (forme indice du caractere)
	int i = 1;  

	// Variable Compteur
	int c = 0;		

	// Variable nombre de caracteres restant a print
	int n = 1;		
	for (int k=1; k<argc; k++){
		n+=string_length((char*) argv[k]);
		n+=1;
	}
	n-=1;
	
	//printf("n vaut : %d\n", n);

	// Concatenation des argv en input
	char* Data2	= (char*) malloc((n)*sizeof(char));
	int tab2[3];
	for(int i2=1; i2<n; i2++){
		print_pointer(i2, argc, argv, tab2);
		if (tab2[2] != 1){
				//printf("%c", (char)(((char*) argv[tab2[0]])[tab2[1]]));
				Data2[i2-1] = (char)(((char*) argv[tab2[0]])[tab2[1]]);
			}
			else {
				//printf("/space/");
				Data2[i2-1] = (char) ' ';
			}
	}
	Data2[n-1] = (char)'\0';

	//printf("\nNew string :%s/\n", Data2);


	// Variable StopSyracuse
	int r = 1;		


	// Variable Syracuse
	char* Data1     = "secret" ; // Mot de passe HMAC
	//char* Data2     = "Anuyan est beaucoup trop chaud";
	PBYTE result = sha256(Data1, Data2);

	//for(int q=0; q<32 ;q++){
	//	printf("%02x",result[q]);
	//}

	char* iv = (char*) malloc(sizeof(int));

	for(int q=0; q< (int) (sizeof(int));q++){
		iv[q] = (char) result[q];
	}
	
	//printf("iv1 = %d\n", iv);

	unsigned int s = (unsigned int) ((int*)iv)[0];	
	//printf("iv = %d\n", s);

	if(s<0){
		printf("ERREUR 0\n"); // s n'est pas considere comme un unsigned int
	}

	// MAIN PROGRAM
	int flag = 0; // flag = True si il ne s'agit pas de la premiere iteration de Syracuse

	while(n>=1){

		if (flag){ // renouvellement de la valeur de s
			//printf("  > Nouvelle valeur de C: %d | ", c);
			char* Data3 = (char*) malloc(5+string_length(Data1));
			for(int q=0; q<string_length(Data1);q++){
				Data3[q] = (char) Data1[q];
			}
			int q = string_length(Data1);
			Data3[q]   = (char) c;
			Data3[q+1] = (char) c+1;
			Data3[q+2] = (char) c+2;
			Data3[q+3] = (char) c+3;
			Data3[q+4] = (char) '\0';

			//printf("length = %d | ", string_length(Data3));

			//printf("Nouveau MDP HMAC : %s | ", Data3);

			PBYTE result2 = sha256(Data3, Data2);

			for(int q=0; q< (int) (sizeof(int));q++){
				iv[q] = (char) result2[q];
			}

			s = (unsigned int) ((int*)iv)[0];

			//printf("iv = %d\n", s);

		}
		else{	// premiere iteration du processus Syracuse
		}

		
		__asm{
syracuse_reset:
		}
		flag++;
		if(s!=1){
			//printf("Syracuse: s = %d\n", s);
			if(s%2==0){
				c++;
				s = s/2;
				// process
			}
			else{
				c+=4;
				s = 3*s+1;
				// process
			}


			if(c>65535){
				s = s >> r;
				r++;
			}
			__asm{
			jmp syracuse_reset
			}

		}
		else{ // s = 1
			print_pointer(i, argc, argv, tab);
			if (tab[2] != 1){
				//char* temp = (char*) argv[tab[0]];
				//printf("%c", (char)temp[tab[1]]);
				printf("%c", (char)(((char*) argv[tab[0]])[tab[1]])); 

			}
			else {
				if(n!=1){ // retire le dernier espace 
					printf(" ");}}
					//printf("/space/");}}
			i++;
			n-=1;
			
		}
	}

	//for(int q=0; q<32 ;q++){
	//	printf("%02x",result[q]);
	//}

	// Decoupage de SHA256 de l'input en 8 morceaux pour comparaison

	for(int q=0; q<4;q++){
		iv[q] = (char) result[q];
	}
	int key1 = (int) ((int*)iv)[0];
	//printf("key1 = %d\n", key1);




	for(int q=0; q<4;q++){
		iv[q] = (char) result[q+4];
	}
	int key2 = (int) ((int*)iv)[0];
	//printf("key2 = %d\n", key2);




	for(int q=0; q<4;q++){
		iv[q] = (char) result[q+8];
	}
	int key3 = (int) ((int*)iv)[0];
	//printf("key3 = %d\n", key3);




	for(int q=0; q<4;q++){
		iv[q] = (char) result[q+12];
	}
	int key4 = (int) ((int*)iv)[0];
	//printf("key4 = %d\n", key4);




	for(int q=0; q<4;q++){
		iv[q] = (char) result[q+16];
	}
	int key5 = (int) ((int*)iv)[0];
	//printf("key5 = %d\n", key5);




	for(int q=0; q<4;q++){
		iv[q] = (char) result[q+20];
	}
	int key6 = (int) ((int*)iv)[0];
	//printf("key6 = %d\n", key6);




	for(int q=0; q<4;q++){
		iv[q] = (char) result[q+24];
	}
	int key7 = (int) ((int*)iv)[0];
	//printf("key7 = %d\n", key7);




	for(int q=0; q<4;q++){
		iv[q] = (char) result[q+28];
	}
	int key8 = (int) ((int*)iv)[0];
	//printf("key8 = %d\n", key8);
	

	// Le hash du mot de passe
	int id1 = 735387704;
	int id2 = -1548699364;
	int id3 = 2064540628;
	int id4 = 492889215;
	int id5 = 775095570;
	int id6 = -495938157;
	int id7 = 1260516048;
	int id8 = -1830798895;

	if(id1==key1 && id2==key2 && id3==key3 && id4==key4 && id5==key5 && id6==key6 && id7==key7 && id8==key8){
		printf("/space/");
	}

	return 0;
}
