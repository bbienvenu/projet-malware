import tatsu 
import random

from tatsu.tool import to_python_sourcecode

arithm_gr = """
@@grammar::arithm

expression = 
            | '(' expression ')' op2 '(' expression ')'
            | expression op2 '(' expression ')'            
            | '(' expression ')' op2 expression
            | expression op2 expression
            | op1 '(' expression ')'
            | op1 expression
            | nombre
            | var ;
            
var = /[a-zA-Z][a-zA-Z0-9]*/ ;

nombre = /[0-9]+/ ;

op1 = '¬' | '−' ;

op2 = '+' | '−' | '⊕' | '∧' | '∨' | '×' ;
"""

class Semantics:
    def nombre(self, ast):
        return {'type' : 'nb', 'val' : int(ast)}
    def var(self, ast):
        return {'type' : 'var', 'val' : ast}
    def expression(self, ast):
        if isinstance(ast, tuple) and len(ast)==3:
            return {'type' : 'op2', 'op' : ast[1], 'val' : (ast[0], ast[2])}
        elif isinstance(ast, tuple) and len(ast)==7:
            return {'type' : 'op2', 'op' : ast[3], 'val' : (ast[1], ast[5])}
        elif isinstance(ast, tuple) and len(ast)==5:
            if ast[0] == '(':
                return {'type' : 'op2', 'op' : ast[3], 'val' : (ast[1], ast[4])}
            return {'type' : 'op2', 'op' : ast[1], 'val' : (ast[0], ast[3])}

        elif isinstance(ast, tuple) and len(ast)==2:
            return {'type' : 'op1', 'op' : ast[0], 'val' : ast[1]}
        elif isinstance(ast, tuple) and len(ast)==4:
            return {'type' : 'op1', 'op' : ast[0], 'val' : ast[2]}
        return ast
    def _default(self, ast):
        return ast

def pp_e(e):
    if e["type"] == 'var':
        return e["val"]
    elif e["type"] == 'nb':
        return str(e["val"])
    elif e["type"] == 'op2':
        if e["op"] == '+':
            return "(%s) + (%s)" % (pp_e(e['val'][0]), pp_e(e['val'][1]))
        elif e["op"] == '−':
            return "(%s) - (%s)" % (pp_e(e['val'][0]), pp_e(e['val'][1]))
        elif e["op"] == '×':
            return "(%s) * (%s)" % (pp_e(e['val'][0]), pp_e(e['val'][1]))
        elif e["op"] == '∧':
            return "(%s) & (%s)" % (pp_e(e['val'][0]), pp_e(e['val'][1]))
        elif e["op"] == '∨':
            return "(%s) | (%s)" % (pp_e(e['val'][0]), pp_e(e['val'][1]))
        elif e["op"] == '⊕':
            return "(%s) ^ (%s)" % (pp_e(e['val'][0]), pp_e(e['val'][1]))
        else:
            raise Exception('operateur non reconnu\n')
    elif e["type"] == 'op1':
        if e["op"] == '−':
            return "-(%s)" % (pp_e(e['val']))
        elif e["op"] == '¬':
            return "~(%s)" % (pp_e(e['val']))
        else:
            raise Exception('operateur non reconnu\n')

    return "Erreur !"

correspondance_add_A = ["((x ∨ y) + y) − ((¬x) ∧ y)", "((x ∨ y) + ((¬x) ∨ y)) − (¬x)", "(−1 + y) − (¬x)", "((2 × (x ∨ y)) − ((¬x) ∧ y)) − (x ∧ (¬y))", "((2 × (−1)) − (¬x)) − (¬y)", "(((x ⊕ y) + (2×(y))) − 2) × ((¬x) ∧ y)", "((x ⊕ y) + (2 × ((¬x) ∨ y))) − (2 × (¬x))", "(−(x ⊕ y) + (2 × y)) + (2 × (x ∧ (¬y)))", "((2 × y) − ((¬x) ∧ y)) + (x ∧ (¬y))", "(2 × y) − ((¬x) + (¬y))", "(y + (x ∧ (¬y))) + (x ∧ y)", "(((¬x) ∧ y) + (x ∧ (¬y))) + (2 × (x ∧ y))"]
correspondance_xor_A = ["((x ∨ y) − y )+ ((¬x) ∧ y)", "((x ∨ y) − ((¬x) ∨ y)) + (¬x)", "((−1) − ((¬x) ∨ y)) + ((¬x) ∧ y)", "((2 × (x ∨ y)) − y) − x", "((2 × (−1)) − ((¬x) ∨ y)) − (x ∨ (¬y))", "(−y + (2 × ((¬x) ∧ y))) + x", "((−((¬x) ∨ y)) + (2 × ((¬x) ∧ y))) + (x ∨ (¬y))", "(y + x) − (2 × (x ∧ y))", "(((¬x) ∨ y) + (x ∨ (¬y))) − (2 × (¬(x ⊕ y)))", "(y + (x ∧ (¬y))) − (x ∧ y)", "(y + (¬y)) − (¬(x ⊕ y))", "(((¬x) ∨ y) + (x ∧ (¬y))) − (¬(x ⊕ y))"]

correspondance_add_B = ["3 × (x ∨ (¬y)) + ((¬x) ∨ y) − (2 × (¬y)) − (2 × (¬(x ⊕ y)))", "−(x ∨ (¬y)) − (¬x) + (x ∧ y) + (2 × (−1))", "(x ∨ (¬y)) + ((((¬x) ∧ y) − (¬(x ∧ y))) + (x ∨ y))", "((2 × (¬(x ⊕ y))) + (3 × ((¬x) ∧ y))) + ((3 × (x ∧ (¬y))) − (2 × (¬(x ∧ y))))"]
correspondance_xor_B = ["((−(x ∨ (¬y)) + ((¬x) ∨ y)) − (2 × (¬(x ∨ y)))) + (2 × (¬y))", "((x ∨ (¬y)) − (3 × (¬(x ∨ y)))) + ((2 × (¬x)) − y)", "((−(x ∨ ¬y) + (¬y)) + (x ∧ (¬y))) + y", "(((x ∨ (¬y)) + ((¬x) ∨ y)) − (2 × (¬(x ∨ y)))) − (2 × (x ∧ y))"]
correspondance_or = ["((x ⊕ y) + y) − ((¬x) ∧ y)", "((x ⊕ y) + ((¬x) ∨ y)) − (¬x)", "(¬(x ∧ y)) + (y − (¬x))", "y + (x − (x ∧ y))", "y + ((x ∨ (¬y)) − (¬(x ⊕ y)))", "((¬x) ∧ y) + ((x ∧ (¬y)) + (x ∧ y))"]
correspondance_and = ["(−(x ∨ y) + y) + x", "(1 + y) + (x ∨ (¬y))", "((x ∨ y) − ((¬x) ∧ y)) − (x ∧ (¬y))", "((−1) − ((¬x) ∧ y)) − (¬y)", "(−(x ⊕ y) + y) + (x ∧ (¬y))", "(−(¬(x ∧ y)) + y) + (¬y)", "(−(¬(x ∧ y)) + ((¬x) ∨ y)) + (x ∧ (¬y))"]


ast_correspondance_add = list()
ast_correspondance_xor = list()
ast_correspondance_or = list()
ast_correspondance_and = list()

for elt in correspondance_add_B:
    ast_correspondance_add.append(tatsu.parse(arithm_gr, elt, semantics=Semantics()))
for elt in correspondance_xor_B:
    ast_correspondance_xor.append(tatsu.parse(arithm_gr, elt, semantics=Semantics()))
for elt in correspondance_or:
    ast_correspondance_or.append(tatsu.parse(arithm_gr, elt, semantics=Semantics()))
for elt in correspondance_and:
    ast_correspondance_and.append(tatsu.parse(arithm_gr, elt, semantics=Semantics()))

# correspondance = {"x + y" : correspondance_add_B, "x ^ y" : correspondance_xor_B, "x | y" : correspondance_or, "x & y" : correspondance_and}

# def complexificator_OG(expression : str)-> str:
#     if expression in correspondance:
#         return random.choice(correspondance[expression])
#     return "Erreur, pas encore implémenté"

def conversion(expression):
    to_replace = {'-':'−', '^':'⊕', '*':'×', '&':'∧', '|':'∨', '~':'¬'}
    nv_expression = ''
    for elt in expression:
        if elt in to_replace:
            nv_expression += to_replace[elt]
        else:
            nv_expression += elt
    return nv_expression

def complexificator_add(exp1, exp2):
    to_replace = {"x" : "(" + pp_e(exp1) + ")", "y" : "(" + pp_e(exp2) + ")"}
    expr_complexe = random.choice(correspondance_add_B)
    nv_expression = ''
    for element in expr_complexe:
        if element in to_replace:
            nv_expression += to_replace[element]
        else:
            nv_expression += element
    return tatsu.parse(arithm_gr, conversion(nv_expression), semantics=Semantics())

def complexificator_xor(exp1, exp2):
    to_replace = {"x" : "(" + pp_e(exp1) + ")", "y" : "(" + pp_e(exp2) + ")"}
    expr_complexe = random.choice(correspondance_xor_B)
    nv_expression = ''
    for element in expr_complexe:
        if element in to_replace:
            nv_expression += to_replace[element]
        else:
            nv_expression += element
    return tatsu.parse(arithm_gr, conversion(nv_expression), semantics=Semantics())

def complexificator_or(exp1, exp2):
    to_replace = {"x" : "(" + pp_e(exp1) + ")", "y" : "(" + pp_e(exp2) + ")"}
    expr_complexe = random.choice(correspondance_or)
    nv_expression = ''
    for element in expr_complexe:
        if element in to_replace:
            nv_expression += to_replace[element]
        else:
            nv_expression += element
    return tatsu.parse(arithm_gr, conversion(nv_expression), semantics=Semantics())

def complexificator_and(exp1, exp2):
    to_replace = {"x" : "(" + pp_e(exp1) + ")", "y" : "(" + pp_e(exp2) + ")"}
    expr_complexe = random.choice(correspondance_and)
    nv_expression = ''
    for element in expr_complexe:
        if element in to_replace:
            nv_expression += to_replace[element]
        else:
            nv_expression += element
    return tatsu.parse(arithm_gr, conversion(nv_expression), semantics=Semantics())

def complexificator(expression, depth=2):
    if isinstance(expression, str):
        expr = tatsu.parse(arithm_gr, expression, semantics=Semantics())
    else:
        expr = expression
    while depth != 0:
        if expr["type"] == "op2":
            # print("HERE")
            # print(expr)
            if expr["op"] == "+":
                expr = complexificator_add(expr["val"][0], expr["val"][1])
            elif expr["op"] == "⊕":
                expr = complexificator_xor(expr["val"][0], expr["val"][1])
            elif expr["op"] == "∧":
                expr = complexificator_and(expr["val"][0], expr["val"][1])
            elif expr["op"] == "∨":
                expr = complexificator_or(expr["val"][0], expr["val"][1])
        depth -= 1
    return expr


print(pp_e(complexificator("x + y")))
