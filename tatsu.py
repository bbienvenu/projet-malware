import tatsu 

arithm_gr = """
@@grammar::arithm

expression = 
            | '(' expression ')' op2 '(' expression ')'
            | expression op2 '(' expression ')'            
            | '(' expression ')' op2 expression
            | expression op2 expression
            | op1 '(' expression ')'
            | op1 expression
            | nombre
            | var ;
            
var = /[a-zA-Z][a-zA-Z0-9]*/ ;

nombre = /[0-9]+/ ;

op1 = '¬' | '−' ;

op2 = '+' | '−' | '⊕' | '∧' | '∨' | '×' ;
"""

class Semantics:
    def nombre(self, ast):
        return {'type' : 'nb', 'val' : int(ast)}
    def var(self, ast):
        return {'type' : 'var', 'val' : ast}
    def expression(self, ast):
        if isinstance(ast, tuple) and len(ast)==3:
            return {'type' : 'op2', 'op' : ast[1], 'val' : (ast[0], ast[2])}
        elif isinstance(ast, tuple) and len(ast)==7:
            return {'type' : 'op2', 'op' : ast[3], 'val' : (ast[1], ast[5])}
        elif isinstance(ast, tuple) and len(ast)==5:
            if ast[0] == '(':
                return {'type' : 'op2', 'op' : ast[3], 'val' : (ast[1], ast[4])}
            return {'type' : 'op2', 'op' : ast[1], 'val' : (ast[0], ast[3])}

        elif isinstance(ast, tuple) and len(ast)==2:
            return {'type' : 'op1', 'op' : ast[0], 'val' : ast[1]}
        elif isinstance(ast, tuple) and len(ast)==4:
            return {'type' : 'op1', 'op' : ast[0], 'val' : ast[2]}
        return ast
    def _default(self, ast):
        return ast

def pp_e(e):
    if e["type"] == 'var':
        return e["val"]
    elif e["type"] == 'nb':
        return str(e["val"])
    elif e["type"] == 'op2':
        if e["op"] == '+':
            return "(%s) + (%s)" % (pp_e(e['val'][0]), pp_e(e['val'][1]))
        elif e["op"] == '−':
            return "(%s) - (%s)" % (pp_e(e['val'][0]), pp_e(e['val'][1]))
        elif e["op"] == '×':
            return "(%s) * (%s)" % (pp_e(e['val'][0]), pp_e(e['val'][1]))
        elif e["op"] == '∧':
            return "(%s) & (%s)" % (pp_e(e['val'][0]), pp_e(e['val'][1]))
        elif e["op"] == '∨':
            return "(%s) | (%s)" % (pp_e(e['val'][0]), pp_e(e['val'][1]))
        elif e["op"] == '⊕':
            return "(%s) ^ (%s)" % (pp_e(e['val'][0]), pp_e(e['val'][1]))
        else:
            raise Exception('operateur non reconnu\n')
    elif e["type"] == 'op1':
        if e["op"] == '−':
            return "-(%s)" % (pp_e(e['val']))
        elif e["op"] == '¬':
            return "~(%s)" % (pp_e(e['val']))
        else:
            raise Exception('operateur non reconnu\n')

    return "Erreur !"

# 3 × (x ∨ ¬y) + (¬x ∨ y) − 2 × (¬y) − 2 × (¬(x ⊕ y))

a = tatsu.parse(arithm_gr, "3 × (x ∨ ¬y) + ((¬x) ∨ y) − (2 × (¬y)) − (2 × (¬(x ⊕ y)))", semantics=Semantics())

print(a)

print("\n")

print(pp_e(a))

print("THE END")
