import tatsu 
import random

arithm_gr = """
@@grammar::arithm

expression = 
            | '(' expression ')' op2 '(' expression ')'
            | expression op2 '(' expression ')'            
            | '(' expression ')' op2 expression
            | expression op2 expression
            | op1 '(' expression ')'
            | op1 expression
            | nombre
            | var ;
            
var = /[a-zA-Z][a-zA-Z0-9]*/ ;

nombre = /[0-9]+/ ;

op1 = '¬' | '−' ;

op2 = '+' | '−' | '⊕' | '∧' | '∨' | '×' ;
"""

class Semantics:
    def nombre(self, ast):
        return {'type' : 'nb', 'val' : int(ast)}
    def var(self, ast):
        return {'type' : 'var', 'val' : ast}
    def expression(self, ast):
        if isinstance(ast, tuple) and len(ast)==3:
            return {'type' : 'op2', 'op' : ast[1], 'val' : (ast[0], ast[2])}
        elif isinstance(ast, tuple) and len(ast)==7:
            return {'type' : 'op2', 'op' : ast[3], 'val' : (ast[1], ast[5])}
        elif isinstance(ast, tuple) and len(ast)==5:
            if ast[0] == '(':
                return {'type' : 'op2', 'op' : ast[3], 'val' : (ast[1], ast[4])}
            return {'type' : 'op2', 'op' : ast[1], 'val' : (ast[0], ast[3])}

        elif isinstance(ast, tuple) and len(ast)==2:
            return {'type' : 'op1', 'op' : ast[0], 'val' : ast[1]}
        elif isinstance(ast, tuple) and len(ast)==4:
            return {'type' : 'op1', 'op' : ast[0], 'val' : ast[2]}
        return ast
    def _default(self, ast):
        return ast

def pp_e(e):
    if e["type"] == 'var':
        return e["val"]
    elif e["type"] == 'nb':
        return str(e["val"])
    elif e["type"] == 'op2':
        if e["op"] == '+':
            return "(%s) + (%s)" % (pp_e(e['val'][0]), pp_e(e['val'][1]))
        elif e["op"] == '−':
            return "(%s) - (%s)" % (pp_e(e['val'][0]), pp_e(e['val'][1]))
        elif e["op"] == '×':
            return "(%s) * (%s)" % (pp_e(e['val'][0]), pp_e(e['val'][1]))
        elif e["op"] == '∧':
            return "(%s) & (%s)" % (pp_e(e['val'][0]), pp_e(e['val'][1]))
        elif e["op"] == '∨':
            return "(%s) | (%s)" % (pp_e(e['val'][0]), pp_e(e['val'][1]))
        elif e["op"] == '⊕':
            return "(%s) ^ (%s)" % (pp_e(e['val'][0]), pp_e(e['val'][1]))
        else:
            raise Exception('operateur non reconnu\n')
    elif e["type"] == 'op1':
        if e["op"] == '−':
            return "-(%s)" % (pp_e(e['val']))
        elif e["op"] == '¬':
            return "~(%s)" % (pp_e(e['val']))
        else:
            raise Exception('operateur non reconnu\n')

    return "Erreur !"

correspondance_add_A = ["((x ∨ y) + y) − ((¬x) ∧ y)", "((x ∨ y) + ((¬x) ∨ y)) − (¬x)", "(−1 + y) − (¬x)", "((2 × (x ∨ y)) − ((¬x) ∧ y)) − (x ∧ (¬y))", "((2 × (−1)) − (¬x)) − (¬y)", "(((x ⊕ y) + (2×(y))) − 2) × ((¬x) ∧ y)", "((x ⊕ y) + (2 × ((¬x) ∨ y))) − (2 × (¬x))", "(−(x ⊕ y) + (2 × y)) + (2 × (x ∧ (¬y)))", "((2 × y) − ((¬x) ∧ y)) + (x ∧ (¬y))", "(2 × y) − ((¬x) + (¬y))", "(y + (x ∧ (¬y))) + (x ∧ y)", "(((¬x) ∧ y) + (x ∧ (¬y))) + (2 × (x ∧ y))"]
correspondance_xor_A = ["((x ∨ y) − y )+ ((¬x) ∧ y)", "((x ∨ y) − ((¬x) ∨ y)) + (¬x)", "((−1) − ((¬x) ∨ y)) + ((¬x) ∧ y)", "((2 × (x ∨ y)) − y) − x", "((2 × (−1)) − ((¬x) ∨ y)) − (x ∨ (¬y))", "(−y + (2 × ((¬x) ∧ y))) + x", "((−((¬x) ∨ y)) + (2 × ((¬x) ∧ y))) + (x ∨ (¬y))", "(y + x) − (2 × (x ∧ y))", "(((¬x) ∨ y) + (x ∨ (¬y))) − (2 × (¬(x ⊕ y)))", "(y + (x ∧ (¬y))) − (x ∧ y)", "(y + (¬y)) − (¬(x ⊕ y))", "(((¬x) ∨ y) + (x ∧ (¬y))) − (¬(x ⊕ y))"]

correspondance_add_B = ["3 × (x ∨ (¬y)) + ((¬x) ∨ y) − (2 × (¬y)) − (2 × (¬(x ⊕ y)))", "−(x ∨ (¬y)) − (¬x) + (x ∧ y) + (2 × (−1))", "(x ∨ (¬y)) + ((((¬x) ∧ y) − (¬(x ∧ y))) + (x ∨ y))", "((2 × (¬(x ⊕ y))) + (3 × ((¬x) ∧ y))) + ((3 × (x ∧ (¬y))) − (2 × (¬(x ∧ y))))"]
correspondance_xor_B = ["((−(x ∨ (¬y)) + ((¬x) ∨ y)) − (2 × (¬(x ∨ y)))) + (2 × (¬y))", "((x ∨ (¬y)) − (3 × (¬(x ∨ y)))) + ((2 × (¬x)) − y)", "((−(x ∨ ¬y) + (¬y)) + (x ∧ (¬y))) + y", "(((x ∨ (¬y)) + ((¬x) ∨ y)) − (2 × (¬(x ∨ y)))) − (2 × (x ∧ y))"]

correspondance_add = correspondance_add_A + correspondance_add_B
correspondance_xor = correspondance_xor_A + correspondance_xor_B
correspondance_or = ["((x ⊕ y) + y) − ((¬x) ∧ y)", "((x ⊕ y) + ((¬x) ∨ y)) − (¬x)", "(¬(x ∧ y)) + (y − (¬x))", "y + (x − (x ∧ y))", "y + ((x ∨ (¬y)) − (¬(x ⊕ y)))", "((¬x) ∧ y) + ((x ∧ (¬y)) + (x ∧ y))"]
correspondance_and = ["(−(x ∨ y) + y) + x", "(1 + y) + (x ∨ (¬y))", "((x ∨ y) − ((¬x) ∧ y)) − (x ∧ (¬y))", "((−1) − ((¬x) ∧ y)) − (¬y)", "(−(x ⊕ y) + y) + (x ∧ (¬y))", "(−(¬(x ∧ y)) + y) + (¬y)", "(−(¬(x ∧ y)) + ((¬x) ∨ y)) + (x ∧ (¬y))"]


# changement des noms de variables 
# correspondance_add_A = ["((theta ∨ omicron) + omicron) − ((¬theta) ∧ omicron)", "((theta ∨ omicron) + ((¬theta) ∨ omicron)) − (¬theta)", "(−1 + omicron) − (¬theta)", "((2 × (theta ∨ omicron)) − ((¬theta) ∧ omicron)) − (theta ∧ (¬omicron))", "((2 × (−1)) − (¬theta)) − (¬omicron)", "(((theta ⊕ omicron) + (2×(omicron))) − 2) × ((¬theta) ∧ omicron)", "((theta ⊕ omicron) + (2 × ((¬theta) ∨ omicron))) − (2 × (¬theta))", "(−(theta ⊕ omicron) + (2 × omicron)) + (2 × (theta ∧ (¬omicron)))", "((2 × omicron) − ((¬theta) ∧ omicron)) + (theta ∧ (¬omicron))", "(2 × omicron) − ((¬theta) + (¬omicron))", "(omicron + (theta ∧ (¬omicron))) + (theta ∧ omicron)", "(((¬theta) ∧ omicron) + (theta ∧ (¬omicron))) + (2 × (theta ∧ omicron))"]
# correspondance_xor_A = ["((theta ∨ omicron) − omicron )+ ((¬theta) ∧ omicron)", "((theta ∨ omicron) − ((¬theta) ∨ omicron)) + (¬theta)", "((−1) − ((¬theta) ∨ omicron)) + ((¬theta) ∧ omicron)", "((2 × (theta ∨ omicron)) − omicron) − theta", "((2 × (−1)) − ((¬theta) ∨ omicron)) − (theta ∨ (¬omicron))", "(−omicron + (2 × ((¬theta) ∧ omicron))) + theta", "((−((¬theta) ∨ omicron)) + (2 × ((¬theta) ∧ omicron))) + (theta ∨ (¬omicron))", "(omicron + theta) − (2 × (theta ∧ omicron))", "(((¬theta) ∨ omicron) + (theta ∨ (¬omicron))) − (2 × (¬(theta ⊕ omicron)))", "(omicron + (theta ∧ (¬omicron))) − (theta ∧ omicron)", "(omicron + (¬omicron)) − (¬(theta ⊕ omicron))", "(((¬theta) ∨ omicron) + (theta ∧ (¬omicron))) − (¬(theta ⊕ omicron))"]

# correspondance_add_B = ["3 × (theta ∨ (¬omicron)) + ((¬theta) ∨ omicron) − (2 × (¬omicron)) − (2 × (¬(theta ⊕ omicron)))", "−(theta ∨ (¬omicron)) − (¬theta) + (theta ∧ omicron) + (2 × (−1))", "(theta ∨ (¬omicron)) + ((((¬theta) ∧ omicron) − (¬(theta ∧ omicron))) + (theta ∨ omicron))", "((2 × (¬(theta ⊕ omicron))) + (3 × ((¬theta) ∧ omicron))) + ((3 × (theta ∧ (¬omicron))) − (2 × (¬(theta ∧ omicron))))"]
# correspondance_xor_B = ["((−(theta ∨ (¬omicron)) + ((¬theta) ∨ omicron)) − (2 × (¬(theta ∨ omicron)))) + (2 × (¬omicron))", "((theta ∨ (¬omicron)) − (3 × (¬(theta ∨ omicron)))) + ((2 × (¬theta)) − omicron)", "((−(theta ∨ ¬omicron) + (¬omicron)) + (theta ∧ (¬omicron))) + omicron", "(((theta ∨ (¬omicron)) + ((¬theta) ∨ omicron)) − (2 × (¬(theta ∨ omicron)))) − (2 × (theta ∧ omicron))"]

# correspondance_add = correspondance_add_A + correspondance_add_B
# correspondance_xor = correspondance_xor_A + correspondance_xor_B
# correspondance_or = ["((theta ⊕ omicron) + omicron) − ((¬theta) ∧ omicron)", "((theta ⊕ omicron) + ((¬theta) ∨ omicron)) − (¬theta)", "(¬(theta ∧ omicron)) + (omicron − (¬theta))", "omicron + (theta − (theta ∧ omicron))", "omicron + ((theta ∨ (¬omicron)) − (¬(theta ⊕ omicron)))", "((¬theta) ∧ omicron) + ((theta ∧ (¬omicron)) + (theta ∧ omicron))"]
# correspondance_and = ["(−(theta ∨ omicron) + omicron) + theta", "(1 + omicron) + (theta ∨ (¬omicron))", "((theta ∨ omicron) − ((¬theta) ∧ omicron)) − (theta ∧ (¬omicron))", "((−1) − ((¬theta) ∧ omicron)) − (¬omicron)", "(−(theta ⊕ omicron) + omicron) + (theta ∧ (¬omicron))", "(−(¬(theta ∧ omicron)) + omicron) + (¬omicron)", "(−(¬(theta ∧ omicron)) + ((¬theta) ∨ omicron)) + (theta ∧ (¬omicron))"]


# fonction pour convertir une expression type 'cpp' au format du pdf
def conversion(expression):
    to_replace = {'-':'−', '^':'⊕', '*':'×', '&':'∧', '|':'∨', '~':'¬'}
    nv_expression = ''
    for elt in expression:
        if elt in to_replace:
            nv_expression += to_replace[elt]
        else:
            nv_expression += elt
    return nv_expression

# Etant donné les deux membres d'une addition, retourne un ast plus "complexe" suivant les regles du pdf
def complexificator_add(exp1, exp2):
    to_replace = {"x" : "(" + pp_e(exp1) + ")", "y" : "(" + pp_e(exp2) + ")"}
    expr_complexe = random.choice(correspondance_add_B)
    nv_expression = ''
    for element in expr_complexe:
        if element in to_replace:
            nv_expression += to_replace[element]
        else:
            nv_expression += element
    return tatsu.parse(arithm_gr, conversion(nv_expression), semantics=Semantics())

# Etant donné les deux membres d'un xor, retourne un ast plus "complexe" suivant les regles du pdf
def complexificator_xor(exp1, exp2):
    to_replace = {"x" : "(" + pp_e(exp1) + ")", "y" : "(" + pp_e(exp2) + ")"}
    expr_complexe = random.choice(correspondance_xor_B)
    nv_expression = ''
    for element in expr_complexe:
        if element in to_replace:
            nv_expression += to_replace[element]
        else:
            nv_expression += element
    return tatsu.parse(arithm_gr, conversion(nv_expression), semantics=Semantics())

# Etant donné les deux membres d'un or, retourne un ast plus "complexe" suivant les regles du pdf
def complexificator_or(exp1, exp2):
    to_replace = {"x" : "(" + pp_e(exp1) + ")", "y" : "(" + pp_e(exp2) + ")"}
    expr_complexe = random.choice(correspondance_or)
    nv_expression = ''
    for element in expr_complexe:
        if element in to_replace:
            nv_expression += to_replace[element]
        else:
            nv_expression += element
    return tatsu.parse(arithm_gr, conversion(nv_expression), semantics=Semantics())

# Etant donné les deux membres d'un and, retourne un ast plus "complexe" suivant les regles du pdf
def complexificator_and(exp1, exp2):
    to_replace = {"x" : "(" + pp_e(exp1) + ")", "y" : "(" + pp_e(exp2) + ")"}
    expr_complexe = random.choice(correspondance_and)
    nv_expression = ''
    for element in expr_complexe:
        if element in to_replace:
            nv_expression += to_replace[element]
        else:
            nv_expression += element
    return tatsu.parse(arithm_gr, conversion(nv_expression), semantics=Semantics())

# Retourne une expression (ast) plus complexe
def complexificator(expression, depth=20):
    if isinstance(expression, str):
        expr = tatsu.parse(arithm_gr, expression, semantics=Semantics())
    else:
        expr = expression
    while depth != 0:
        if expr["type"] == "op2":
            if expr["op"] == "+":
                expr = complexificator_add(expr["val"][0], expr["val"][1])
            elif expr["op"] == "⊕":
                expr = complexificator_xor(expr["val"][0], expr["val"][1])
            elif expr["op"] == "∧":
                expr = complexificator_and(expr["val"][0], expr["val"][1])
            elif expr["op"] == "∨":
                expr = complexificator_or(expr["val"][0], expr["val"][1])
        depth -= 1
    return expr


for k in range(16, 21):
    with open("add%s"%k, 'w') as fa:
        print(pp_e(complexificator("x + y", 2+k)), file=fa)
    fa.close()

print("DONE")
